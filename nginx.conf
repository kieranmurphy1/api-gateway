user  nginx;
worker_processes  auto;

# Kieran Murphy: added this line to fix error: accept4() failed (24: Too many open files)
# But then it caused another error: [alert] 156211#156211: setrlimit(RLIMIT_NOFILE, 60000) failed (13: Permission denied)
# 2021-12-08 Increase open files
# worker_rlimit_nofile 30000;
# worker_rlimit_nofile 3000;

# error_log  /var/log/nginx/error.log notice;
#error_log  /var/log/nginx/error.log info;     # preferred log level
error_log  /var/log/nginx/error.log debug;   # generates large files
pid        /var/run/nginx.pid;

# Kieran Murphy Added NDK and Lua Modules:
load_module modules/ndk_http_module.so;
load_module modules/ngx_http_lua_module.so;
load_module modules/ngx_stream_lua_module.so;

# Kieran Murphy Added NJS Dynamic Modules:
load_module modules/ngx_http_js_module.so;
load_module modules/ngx_stream_js_module.so;

# Kieran Murphy - increased the following from 1024 to 4096 to fix error: accept4() failed (24: Too many open files)
#    worker_connections  8192;
events {
    worker_connections  1024;
}


http {
    # Kieran Murphy: Increase the size of the buffer for storing subrequest response bodies.
    subrequest_output_buffer_size 32k;   # default is 4k or 8k depending on the platform.
    # Added DNS Resolver - Kieran Murphy
    resolver 192.168.0.1;
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # Note the double quotes "" in the log_format are printed in the logfile i.e. they are not used as escape characters.
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    log_format altlog $name;
    log_format jwt '$remote_addr - $remote_user [$time_local] "$request"'
        ' $status $body_bytes_sent "$http_referer" "$http_user_agent" "http_maximo_user_id = $http_maximo_user_id"'
        ' "jwt_mip_sAMAccountName = $jwt_mip_sAMAccountName" "jwt_mip_employeeid = $jwt_mip_employeeid"'
        ' "maximoapikeyref = $maximoapikeyref"';
    log_format  postdata escape=json '[$time_local] "$request_method" "$request" "$request_body" "$http_apikey" "$http_request_maximo" "$uri" "$status"';
    # Multiple logging directives are allowed in the same context:
    access_log  /var/log/nginx/access.log  main;        # Configure main log at the http context as applies to all servers.
    access_log  /var/log/nginx/postdata.log  postdata;    

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
# Added Kieran Murphy
# Define the NGINX Lua search path for lua script files:
#    lua_package_path  "/etc/nginx/conf.d/lua/?.lua;;";
#    lua_package_path  "/etc/nginx/conf.d/lua/?.lua;/usr/local/share/lua/5.4/?.lua;/usr/local/lib/lua/5.4/socket/?.so;;";
    lua_package_path  "/etc/nginx/conf.d/lua/?.lua;/usr/local/share/lua/5.4/?.lua;/usr/local/lib/lua/?.lua;;";
#    lua_package_cpath  "/usr/local/lib/lua/5.1/?.so;/usr/local/lib/lua/5.4/?.so;;";
###    lua_package_cpath  "/usr/local/lib/lua/5.4/?.so;;";
# Optional Pre-loading of lua modules:
    init_by_lua_block { 
        require "json"
        require "cjson"
        require "socket.http"
        require "ltn12"
        require "logging"
        require "resty.http"
    }

# Define the server to which we will route all requests:
    upstream api_server {
      server 127.0.0.1:8089;
    }

    upstream maximo_api_server {
      zone maximo_api_server 64k; # Configure shared memory segment for statistics data collection.
      #server iwdc1proj2max05.iwater.ie:80;
      #server localhost:8089;                       # Node.js echo.js echo server. 
      server maximo-project2.vip.iwater.ie:9000;    # Node.js api-gateway.js api endpoint simulator.
      keepalive 4;
    }

    upstream jwt_server {      
      zone jwt_server 64k; # Configure shared memory segment for statistics data collection.
      server 127.0.0.1:9080;
    }
    
    upstream nginx_api_gateway {
      #server iwdc1proj2max05.iwater.ie:80;
      server 127.0.0.1:8080;
    }

# Added Kieran Murphy - include Prometheus NJS file:
    js_import /usr/share/nginx-plus-module-prometheus/prometheus.js;
# Added Kieran Murphy - load NJS source files
    js_path "/etc/nginx/conf.d/njs/";            # set the root path for js_import
    js_import njs-examples/njs/utils.js;
    js_import main from njs-examples/njs/http/hello.js;
    js_import mip/introspectAccessToken.js;
    js_import mip/json_log.js;                  # Function to log errors in JSON format.
    #js_import mip/jsonwebtoken_static.js;

# Configure mapping of $status to flag variable $is_error for diagnostic conditional logging to a dedicated logfile, see access_debug log_format:
    map $upstream_status $multi_upstreams {
        "~,"    1; # Has a comma
        default 0;
    }
    map $status $is_error {
        400     1; # Bad request, including expired client cert
        404     1; # Page not found
        495     1; # Client cert error
        499     1; # Client closes the connection while nginx is processing the request
        500     1; # Internal Server Error
        502     1; # Bad gateway (no upstream server could be selected)
        504     1; # Gateway timeout (couldn't connect to selected upstream)        
        597     1; # No custom header or JWT for Maximo UserId (use to test the JSON debug log as not a system error)
        default $multi_upstreams; # If we tried more than one upstream server
    }
# Assign NJS function names to variable and configure NJS logging formatter:
    js_set $json_debug_log json_log.debugLog;  # Assign variable with JSON "debugLog()" function for logging debug information in json format.
    log_format access_debug escape=none $json_debug_log; # Offload to njs function debugLog().
# Assign NJS function names to variables:    
    js_set $name main.hello;                        # NJS function is called when the variable is referenced.
    js_set $tokenFromHeader utils.tokenFromHeader;  # NJS function is called when the variable is referenced.
    #js_set $verifyjwt introspectAccessToken.verifyjwt;    
    #js_set $verifyjwt jsonwebtoken-static.verifyjwt;
# Assign NJS variables (use set for NGINX global variables)
    js_var $jwt_keycloak_user_name $jwt_claim_user_name;  # Assign JWT Keycloak Claim variable to NGINX global variable.
    js_var $jwt_mip_given_name $jwt_claim_given_name;     # Assign JWT MIP Test Claim variable to NGINX global variable.
    js_var $jwt_mip_unique_name $jwt_claim_unique_name;   # Assign JWT MIP Test Claim variable to NGINX global variable.
    js_var $jwt_mip_sAMAccountName $jwt_claim_sAMAccountName;   # Assign JWT MIP Hybrid User Claim variable to NGINX global variable.
    js_var $jwt_mip_employeeid $jwt_claim_employeeid;       # Assign JWT MIP Cloud Only User Claim variable to NGINX global variable.
    js_var $maximo_MXINTADM_apikey n1r16irr;           # Maximo Admin API Key used in call to get a specific user apikey.
    js_var $maximo_PCREWF19_basic_auth "Basic UENSRVdGMTk6TWF4aW1vMSQ=";  # Maximo Ordinary User Basic Authorization Header Value.
    js_var $maximo_admin_basic_auth "Basic bWF4YWRtaW46bWF4YWRtaW4xMjA3";  # Maximo Admin User Basic Authorization Header Value.
    js_var $maximoapikeyref;                        # Used to delete Maximo API Key.
    js_var $use_maximo_apikeys_cache false;         # Use cached Maximo apikey.
    js_var $validateTokenFlag true;                # if true, perform realtime JWT Validation using JWT server in NJS function validateAccessTokenCache() or validateAccessToken().    
    js_var $use_jwt_token_cache false;         # Use cached JWT token "true" validation result.    
    js_var $token_test '{"exp":1637274927,"iat":1637274627,"auth_time":1637274627,"jti":"6f61b396-72d0-4afc-a6c3-c184570eb81e","iss":"http://localhost:9080/auth/realms/dev","aud":"account","sub":"14927d57-2ced-4d65-9903-bdb0ce90e2d9","typ":"Bearer","azp":"employee-service","session_state":"0e88b6ca-66bb-400a-9fdc-bcb4de8fe7c7","name":"Rachel White","given_name":"Rachel","family_name":"White","preferred_username":"rachel","email_verified":false,"acr":"1","realm_access":{"roles":["default-roles-dev","offline_access","uma_authorization"]},"resource_access":{"account":{"roles":["manage-account","manage-account-links","view-profile"]},"employee-service":{"roles":["USER"]}},"scope":"openid profile email","sid":"0e88b6ca-66bb-400a-9fdc-bcb4de8fe7c7","user_name":"rachel","client_id":"employee-service","username":"rachel","active":true}';
    js_var $token_test_mip '{ "aud": "https://mymipapi.water.ie", "iss": "https://sts.windows.net/60beb100-3973-4346-bd68-d1c4eb6f4c42/", "iat": 1647344539, "nbf": 1647344539, "exp": 1647349842, "acr": "1", "aio": "ATQAy/8TAAAACt+GMFu6Z4ovwi6v/Vc+fL5A2GOsA0L07FS61XVnlV9olt+6pu2KRMEwzb/hl6L7", "amr": [ "wia" ], "appid": "f0438299-3c05-4ea6-965e-07cfdf9479a2", "appidacr": "0", "family_name": "Pal", "given_name": "Shaswata", "hasgroups": "true", "in_corp": "true", "ipaddr": "82.141.218.220", "name": "Shaswata Pal (C)", "oid": "973c0b4a-3b04-43c2-8f94-60c386a63fcb", "onprem_sid": "S-1-5-21-2630432783-15384281-2988178474-44906", "rh": "0.AV4AALG-YHM5RkO9aNHE629MQskUgH_HSaxDuzzybFFg1TNeAIA.", "scp": "Files.Read", "sub": "SUBd1ms5xuCS9fFYr4JHr8Fn0OxIL8aHml5AJqXtZ8E", "tenant_ctry": "IE", "tid": "60beb100-3973-4346-bd68-d1c4eb6f4c42", "unique_name": "shaswata.pal @water.ie", "upn": "shaswata.pal @water.ie", "uti": "QX9CmFtpH0izs-RhRC-FAA", "ver": "1.0", "sAMAccountName": "spal", "active": true }';
    
    # Configure distributed memory cache for OAuth tokens using the Authorization header as the key:
    keyval_zone zone=access_tokens:4m timeout=60s sync;
    keyval $http_authorization $token_cache zone=access_tokens;
    # Configure distributed memory cache for Maximo API keys using the header MAXIM0-USER-ID as the key:
    keyval_zone zone=access_maximoapikeys:4m timeout=50s sync;   # Maximo apikey expiration = 50 seconds
    keyval $http_maximo_user_id $maximo_apikeys_cache zone=access_maximoapikeys;

    server {
    #  listen 127.0.0.1:8080;
        listen *:8080;
        root   /etc/nginx/html;       
    #access_log /var/log/nginx/postdata.log postdata;
        access_log /var/log/nginx/access_debug.log access_debug if=$is_error; # Diagnostic logging        
    # ...
    # Configure Zone for statistics monitoring:
        status_zone irishwater_apigateway;
    # Assign NGINX variables (used in location blocks):
        set $JWT_KEYCLOAK_USER_NAME $jwt_claim_user_name;  # Assign JWT Keycloak Claim variable to NGINX global variable.
        set $JWT_MIP_GIVEN_NAME $jwt_claim_given_name;     # Assign JWT MIP Test Claim variable to NGINX global variable.
        set $JWT_MIP_UNIQUE_NAME $jwt_claim_unique_name;   # Assign JWT MIP Test Claim variable to NGINX global variable.
        set $JWT_MIP_SAMACCOUNTNAME $jwt_claim_sAMAccountName;   # Assign JWT MIP Hybrid User Claim variable to NGINX global variable.
        set $JWT_MIP_EMPLOYEEID $jwt_claim_employeeid;       # Assign JWT MIP Cloud Only User Claim variable to NGINX global variable.                

    # Include a location for Prometheus metrics:
       location = /metrics {
            js_content prometheus.metrics;
        }
    # ...    
    # Enable the /api location to expose the /metrics endpoint from Prometheus:
        location /api {
            api;
        }
    # Enable the dashboard for statistics:
        location = /dashboard.html {
            root   /usr/share/nginx/html;
        }        
    #... Define Custom Error Pages:
        error_page 596 /596-introspectAccessToken.html;
        location = /596-introspectAccessToken.html { 
           allow all;
           internal;
       }     
        error_page 597 /597-header.html;
        location = /597-header.html { 
           allow all;
           internal;
       }        
        error_page 598 /598-header.html;
        location = /598-header.html { 
           allow all;
           internal;
       }        
        error_page 599 /599-header.html;
        location = /599-header.html { 
           allow all;
           internal;
       }   
    # ...
        location /njs_hello1 {
            js_content main.hello;                       
        }
    # ...
        location /njs_hello2 {
            return 200 $name;
            access_log /var/log/nginx/error.log altlog;            
        }
     # ...
        location /njs_writetoken {
            js_content introspectAccessToken.writeToken;                       
        }
     # ...
        location /njs_readtoken {
            js_content introspectAccessToken.readToken;                       
        }        
    # ...
        location /njs_introspectaccesstoken {       
            js_content introspectAccessToken.introspectAccessToken;
            access_log /var/log/nginx/access_jwt.log jwt;
        }
    # ...
        location /njs_tokenfromheader {
            # this NJS function removes the Bearer label from the Authorization Header 
            return 200 $tokenFromHeader;               
        }
    # ...
        location /njs_verifyjwt {
            # Work in Progress
            # this NJS function parses a JWT which can contain 2 parts (i.e. Bearer xxx) or 1 part.
            # return 200 $verifyjwt;                       
        }
    # ...
        location /addheader {
            # this NJS function adds a request header:
            proxy_set_header    Authorization "Basic ZW1wbG95ZWUtc2VydmljZTpMdzFrR1hENFN4QU5JMG9BMnJIdEZEU2FncEJpbEp5Uw==";
            proxy_set_header    Content-Type "application/x-www-form-urlencoded";
            proxy_set_body      "token=$http_authorization&token_type_hint=access_token";
            proxy_pass http://localhost:8089;
        }
    # ======================= AUTH0 SECTION START =========================================
    # ref: https://www.nginx.com/blog/validating-oauth-2-0-access-tokens-nginx/
    #
        location /njs_jwt1 {           
            js_content introspectAccessToken.introspectAccessToken;     # parse a JSON text token
            access_log /var/log/nginx/access_jwt.log jwt;
        }
    # ...
        location /njs_jwt2 {
            auth_jwt "api-domain.auth0.com";
            #auth_jwt_key_file /etc/nginx/secret.json;
            auth_jwt_key_file /etc/nginx/secret-microsoft.json;
            auth_request /_oauth2_token_validation;     # validate the JWT expiry using the IDP service.
        # if an incoming JWT is valid, then proxy to our upstream server.
        #    proxy_pass http://api_server;
        #    proxy_pass http://localhost:3000;           
        }
    # ...
        location /njs_jwt3 {
            expires -1;         # disable NGINX cache by short expiry
            proxy_no_cache 1;   # disable NGINX cache
            auth_jwt "api-domain.auth0.com";
            #auth_jwt_key_file /etc/nginx/secret.json;       # Keycloak IDP Secret Certificates
            auth_jwt_key_file /etc/nginx/secret-microsoft.json;  # Azure IDP Secret Certificates
            auth_request /_oauth2_token_cache_validation;         # validate the JWT expiry using the IDP service.
            auth_request_set $maximo_apikey $sent_http_maximoapikey;  # this MGINX global variable is set using the HTTP response header from previous auth_request which called an NJS function.
            proxy_set_header apikey $maximo_apikey;       # Use this Maximo apikey for authorization in the API server.
            proxy_set_header Cookie "";   # An empty string means this header will not be passed to upstream server.
        # if an incoming JWT is valid, then PROXY to our upstream Maximo API server or emulator.       
            proxy_pass http://localhost:8089;   # Proxy the request to the api endpoint  
            access_log /var/log/nginx/access_jwt.log jwt;
        }        
     # ...
        location /callback {
            return 200 $request;
        }
     # ...
        location /_oauth2_token_validation {
            #internal;           
            js_content introspectAccessToken.validateAccessToken;     # validate the JWT expiry using the IDP service.
        }        
     # ...
        location /_oauth2_token_cache_validation {            
            #internal;
            js_content introspectAccessToken.validateAccessTokenCache;
            access_log /var/log/nginx/postdata.log postdata;            
        }
     # ...    
        location /_oauth2_send_request {
            # Call the IDP URL to validate the JWT.
            # called from NJS introspectAccessToken.validateAccessTokenCache and assigning token in overriden body from NJS $request_body.
            internal;
            proxy_method      POST;
            #proxy_set_header  Authorization "Bearer **SecretForOAuthServer**";
            #proxy_set_header    Authorization "Basic ZW1wbG95ZWUtc2VydmljZTpMdzFrR1hENFN4QU5JMG9BMnJIdEZEU2FncEJpbEp5Uw==";
            #proxy_set_header Authorization "Basic ZW1wbG95ZWUtc2VydmljZTphYzhjMTc2MS0zNWNmLTQwODktYjU4My1iZDM4ZTgwOWVjNDk=";
            proxy_set_header    Content-Type "application/x-www-form-urlencoded";
            #proxy_set_body      "token=$request_body&token_type_hint=access_token";
            #proxy_set_body      "token_type_hint=requesting_party_token&token=$request_body";
            proxy_set_body      "client_id=employee-service&client_secret=ac8c1761-35cf-4089-b583-bd38e809ec49&token=$request_body";
            #proxy_pass          http://linux01:9080/auth/realms/dev/protocol/openid-connect/token/introspect;            
            proxy_pass          http://jwt_server/auth/realms/dev/protocol/openid-connect/token/introspect;
            access_log          /var/log/nginx/postdata.log postdata;
            proxy_next_upstream error timeout http_500 http_502 non_idempotent off;    # Stop automatic retries of timeout error.
            #proxy_pass          http://localhost:8089;   # echo server for debugging            
        }
    # ...
        location /njs__getapikey-test { 
            # Test the NJS function _getapikey().
            # Assign the HTTP method type in the NJS function for each subrequest.
            proxy_set_header    apikey $maximo_MXINTADM_apikey;               # APIKEY credentials for Maximo Admin User.
            ##proxy_set_header    Authorization $maximo_admin_basic_auth;     # Basic Auth credentials for user maxadmin / maxadmin1207
            # The MAXIMO-USER-ID request header contains the userid value for the getapikey operation.
            js_content introspectAccessToken._getapikey;
            access_log /var/log/nginx/access_jwt.log jwt;                
        }
    # ...
        location /njs_createapikeySync-test {
            #if ($JWT_MIP_UNIQUE_NAME !~* "^shaswata.pal@water.*$") {
            #    return 598;
            #}            
            # Test the NJS function createapikeySync().
            # Assign the HTTP method type in the NJS function for each subrequest.
            proxy_set_header    apikey $maximo_MXINTADM_apikey;               # APIKEY credentials for Maximo Admin User.
            ##proxy_set_header    Authorization $maximo_admin_basic_auth;     # Basic Auth credentials for user maxadmin / maxadmin1207
            # The MAXIMO-USER-ID request header contains the userid value for the getapikey operation.
            js_content introspectAccessToken.createapikeySync;
            access_log /var/log/nginx/access_jwt.log jwt;                
        }        
    # ...
        location /njs_createapikeyAsync-test { 
            # Test the NJS function createapikeyAsync().
            # Assign the HTTP method type in the NJS function for each subrequest.          
            proxy_set_header    apikey $maximo_MXINTADM_apikey;               # APIKEY credentials for Maximo Admin User.
            ##proxy_set_header    Authorization $maximo_admin_basic_auth;     # Basic Auth credentials for user maxadmin / maxadmin1207
            js_content introspectAccessToken.createapikeyAsync;
            access_log /var/log/nginx/access_jwt.log jwt;                
        }
    # ...
        location /njs_deleteapikeyAsync-test { 
            # Test the NJS function deleteapikeyAsync().
            # Assign the HTTP method type in the NJS function for each subrequest.
            proxy_set_header    apikey $maximo_MXINTADM_apikey;               # APIKEY credentials for Maximo Admin User.
            ##proxy_set_header    Authorization $maximo_admin_basic_auth;     # Basic Auth credentials for user maxadmin / maxadmin1207
            # The MAXIMO-USER-ID request header contains the userid value for the getapikey operation.
            js_content introspectAccessToken.deleteapikeyAsync;
            access_log /var/log/nginx/access_jwt.log jwt;                
        }
    # ...
        location /njs_deleteapikeySync-test { 
            # Test the NJS function deleteapikeySync().
            # Assign the HTTP method type in the NJS function for each subrequest.
            proxy_set_header    apikey $maximo_MXINTADM_apikey;               # APIKEY credentials for Maximo Admin User.
            ##proxy_set_header    Authorization $maximo_admin_basic_auth;     # Basic Auth credentials for user maxadmin / maxadmin1207
            # The MAXIMO-USER-ID request header contains the userid value for the getapikey operation.
            js_content introspectAccessToken.deleteapikeySync;
            access_log /var/log/nginx/access_jwt.log jwt;                
        }                   
    # ...
        location /getmaximoapikey {            
            # Use the /maxrest/oslc/.. endpoint for calls using the Maximo "maxadmin" Basic Auth credentials.
            # Use the /maximo/api/.. endpoint for calls using the Maximo "MXINTADM" apikey header.            
            # called from introspectAccessToken.createapikeyAsync which performs get+delete+create for a Maximo API Key.
            # the proxy_set_header directive adds request headers for Maximo API as cannot be done in the calling NJS subrequest function:
            # NOTE: the Body can be assigned values in the calling NJS subrequest function.
            # NOTE: the Body can also be assigned a value using proxy_set_body directive which takes prededence over subrequest.
            # There is no Body required in this API request as all parameters are url encoded.
            # the response contains the user apikey which is assigned to a response header r.headersOut.maximoapikey by the NJS function.           
            # The input Maximo UserId is supplied in a header: MAXIMO-USER-ID.
            proxy_method    GET;
            proxy_set_header    maximo_user_name $jwt_claim_user_name;       # Assign the JWT Custom Claim 
            proxy_set_header    apikey $maximo_MXINTADM_apikey;                # APIKEY credentials for Maximo Admin User.
            ##proxy_set_header    Authorization $maximo_admin_basic_auth;     # Basic Auth credentials for user maxadmin / maxadmin1207
            ##proxy_set_header Cookie Maximo-Null-From-Client;
            proxy_set_header Cookie "";   # An empty string means this header will not be passed to upstream server.
            # proxy_set_header    Content-Type "application/x-www-form-urlencoded";
            
            # Use the name of the upstream server "maximo_api_server" in the redirect url as this will be resolved to the hostname when NGINX starts.            
            # The MAXIMO-USER-ID request header contains the userid value i.e. $http_maximo_user_id whichis resolved when assigning $arg_redirect.
            ##set $arg_redirect "http://maximo_api_server/maxrest/oslc/os/IWMWMGENAPIKEYTOKEN?oslc.select=*&oslc.where=userid=\"$http_maximo_user_id\"&lean=1"; # WORKING
            set $arg_redirect "http://maximo_api_server/maximo/api/os/IWMWMGENAPIKEYTOKEN?oslc.select=*&oslc.where=userid=\"$http_maximo_user_id\"&lean=1";
            proxy_read_timeout 300s;
            proxy_connect_timeout 75s; 
            proxy_pass $arg_redirect;
            access_log /var/log/nginx/postdata.log postdata;
            # proxy_pass http://localhost:8089;
        }
    # ...    
        location /deletemaximoapikey {
            # Use the /maxrest/oslc/.. endpoint for calls using the Maximo "maxadmin" Basic Auth credentials.
            # Use the /maximo/api/.. endpoint for calls using the Maximo "MXINTADM" apikey header.            
            # called from introspectAccessToken.createapikeyAsync which performs get+delete+create for a Maximo API Key.
            # The /getmaximoapikey endpoint is used to return the href URL for deleting the API Key. This URL is modified to use apikeytokenid.
            # the proxy_set_header directive adds request headers for Maximo API as cannot be done in the calling NJS subrequest function:
            # NOTE: the Body can be assigned values in the calling NJS subrequest function.
            # NOTE: the Body can also be assigned a value using proxy_set_body directive which takes prededence over subrequest.
            # There is no Body required in this API request as all parameters are url encoded.
            # The calling NJS function createapikeyAsync supplies the "href" OR "apikeytokenid" parameter for the key to be deleted in a variable: $maximoapikeyref.
            proxy_method    DELETE;
            # proxy_pass_request_headers off;  # drop all the headers of the main request.
            proxy_set_header x-method-override DELETE;   # Set this header at the operation level overriding any value in the main Maximo request as it is different for create/delete sub requests.
            proxy_set_header    apikey $maximo_MXINTADM_apikey;                # APIKEY credentials for Maximo Admin User.
            ##proxy_set_header    Authorization $maximo_admin_basic_auth;     # Basic Auth credentials for user maxadmin / maxadmin1207
            proxy_set_header Cookie "";   # An empty string means this header will not be passed to upstream server.
            # proxy_set_header    Content-Type "application/x-www-form-urlencoded";
            # proxy_set_body      "maximo_user_name=$jwt_claim_user_name, description=Maximo User Name for API key";
            # Use the name of the upstream server in the redirect url as this will be resolved to the hostname when NGINX starts.            
            set $arg_redirect $maximoapikeyref;  # the calling NJS createapikeyAsync(), createapikeySync() sets this NGINX variable $maximoapikeyref.            
            proxy_read_timeout 300s;
            proxy_connect_timeout 75s;          
            #proxy_pass $arg_redirect;
            proxy_pass http://maximo-project2.vip.iwater.ie:9000/maximo/api/os/iwmwmgenapikeytoken/38144;
            # proxy_pass http://localhost:8089;
            access_log /var/log/nginx/access_jwt.log jwt;            
        }
    # ...
        location /createmaximoapikey_admin {
            # Use the /maxrest/oslc/.. endpoint for calls using the Maximo "maxadmin" Basic Auth credentials.
            # Use the /maximo/api/.. endpoint for calls using the Maximo "MXINTADM" apikey header (+THIS CALL+).                      
            # called from introspectAccessToken.createapikeyAsync which performs get+delete+create for a Maximo API Key.
            # the proxy_set_header directive adds request headers for Maximo API as cannot be done in the calling NJS subrequest function:
            # the body is assigned values in the calling NJS subrequest function.
            # the body can also be assigned a value using proxy_set_body directive which takes prededence over subrequest.
            # the response contains the user apikey which is assigned to a response header r.headersOut.maximoapikey by the NJS function.
            # The input Maximo UserId is supplied in a header: MAXIMO-USER-ID.
            # This Maximo API function requires the maxadmin credentials and the Maximo userid in the Body.
            proxy_method    POST;
            # proxy_pass_request_headers off;  # drop all the headers of the main request.
            proxy_set_header x-method-override POST;   # Set this header at the operation level overriding any value in the main Maximo request as it is different for create/delete sub requests.
            proxy_set_header    apikey $maximo_MXINTADM_apikey;     # APIKEY credentials for Maximo Admin User MXINTADM.
            ###proxy_set_header    Authorization $maximo_admin_basic_auth;     # user maxadmin Basic Auth credentials.
            proxy_set_header    Content-Type "application/json";
            proxy_set_header    properties "userid,apikey,apikeytokenid";
            #proxy_set_body "{\"userid\":\"$jwt_claim_user_name\"}";
            proxy_set_body "{\"userid\":\"$http_maximo_user_id\"}";   # The MAXIMO-USER-ID request header contains the userid value.            
            #proxy_set_body  "{\"userid\":\"PCREWF19\"}";
            #proxy_pass http://localhost:8089;            
            proxy_pass http://maximo_api_server/maximo/api/os/IWMWMGENAPIKEYTOKEN?lean=1;
            ###proxy_pass http://maximo-project2.vip.iwater.ie/maximo/oslc/os/IWMWMGENAPIKEYTOKEN?lean=1; # recommended for admin user but returns empty response         
            access_log /var/log/nginx/access_jwt.log jwt;
        }        

    # ...
        location /createmaximoapikey {
            # NOT USED - prefer /createmaximoapikey_admin.
            # Use the /maxrest/oslc/.. endpoint for calls using the Maximo "maxadmin" Basic Auth credentials (+THIS CALL+).
            # Use the /maximo/api/.. endpoint for calls using the Maximo "MXINTADM" apikey header.
            # This request creates an apikey for the Maximo User specified in the BA credentials.         
            # the proxy_set_header directive adds request headers for Maximo API as cannot be done in the calling NJS subrequest function:
            # the body is assigned values in the calling NJS subrequest function.
            # the body can also be assigned a value using proxy_set_body directive which takes prededence over subrequest.
            # the response contains the user apikey which is assigned to a response header r.headersOut.maximoapikey by the NJS function.
            proxy_method    POST;
            proxy_pass_request_headers off;  # drop all the headers of the main request.
            proxy_set_header x-method-override POST;   # Set this header at the operation level overriding any value in the main Maximo request as it is different for create/delete sub requests.
            ###proxy_set_header    apikey $maximo_MXINTADM_apikey;   # KM 04/04/2022 invalid apitoken error
            proxy_set_header    Authorization $maximo_PCREWF19_basic_auth;   # user PCREWF19 base64 encoding TEST.
            proxy_set_header    Content-Type "application/json";
            proxy_set_header    properties "userid,apikey,apikeytokenid";
            proxy_set_body "{\"expiration\":-1}";
            #proxy_pass http://localhost:8089;            
            proxy_pass http://maximo_api_server/maxrest/oslc/apitoken/create;
            access_log /var/log/nginx/access_jwt.log jwt;
        }     

    # ======================= AUTH0 SECTION END =========================================   
    # ======================= Maximo Integration Project SECTION START======================================== 
    # -- The closing / means any requests to URLS beginning with /maximo/api/ are handled.    
    # Use the /maxrest/oslc/.. endpoint for calls using the Maximo "maxadmin" Basic Auth credentials.
    # Use the /maximo/api/.. endpoint for calls using the Maximo "MXINTADM" apikey header.
    # Check for the Maximo UserID being in the HTTP Request Header "MAXIMO-USER-ID" or the following
    # JWT custom claims: sAMAccountName, employeeid.
    # Select the appropriate internal proxy address "MAXIMO_INTERNAL_URI" and assign the "HEADER_MAXIMO" accordingly.
    # This is the only mechanism to assign a value to a request header i.e. using proxy_set_header.

        location /maximo/api/ {
            expires -1;         # disable NGINX cache by short expiry
            proxy_no_cache 1;   # disable NGINX cache
            proxy_set_header apikey $maximo_apikey;       # Use this Maximo apikey for authorization in the API server.
        # Note that NGINX does not support logical combinations of IF conditions, each condition is evaluated separately.            
        # proxy_set_header is not allowed inside an if statement block, use an NGINX placeholder variable $HEADER_MAXIMO.
        # NGINX variable names cannot contain the "-" character, use "_" instead.

        #    set $x-method-override "GET";  # Default is GET, PATCH is used for UPDATE operations. Do not send header "x-method-override" in Maximo API REQUEST as it breaks the NJS sub requests for createapikey_admin().
        #    if ($request_method = "POST") {
        #        set $x_method_override PATCH;                
        #    }
        #    if ($request_method = "DELETE") {
        #        set $x_method_override DELETE;                
        #    }            
        #    proxy_set_header x-method-override $x_method_override; # Set the header for the API call here to avoid inheritance by the previous NJS sub requests;            

            set $HEADER_MAXIMO not_assigned_value;
            set $MAXIMO_INTERNAL_URI not_assigned_value;            
        # Check for JWT custom claim values for Maximo UserID: ^[a-zA-Z0-9@-_]+$ means a string containing 1 or more occurances of the character range anchored with start and end tags.
            if ($JWT_MIP_UNIQUE_NAME ~* "^shaswata.pal@water.*$") {
                # if an incoming JWT is valid, then set the NGINX placeholder variable for "proxy_set_header MAXIMO-USER-ID" and PROXY to our upstream Maximo API server.
                set $HEADER_MAXIMO $JWT_MIP_UNIQUE_NAME;
                # Proxy the request to the /jwt_claim NGINX location as JWT custom claim contains the Maximo UserID.
                set $MAXIMO_INTERNAL_URI maximo/api/jwt_claim/; # The trailing slash is required.
            }
            if ($JWT_MIP_SAMACCOUNTNAME ~* "^[a-zA-Z0-9@-_]+$") {
                # if an incoming JWT is valid, then set the NGINX placeholder variable for "proxy_set_header MAXIMO-USER-ID" and PROXY to our upstream Maximo API server.
                set $HEADER_MAXIMO $JWT_MIP_SAMACCOUNTNAME;
                # Proxy the request to the /jwt_claim NGINX location as JWT custom claim contains the Maximo UserID.
                set $MAXIMO_INTERNAL_URI maximo/api/jwt_claim/; # The trailing slash is required.
            }
            if ($JWT_MIP_EMPLOYEEID ~* "^[a-zA-Z0-9@-_]+$") {
                # if an incoming JWT is valid, then set the NGINX placeholder variable for "proxy_set_header MAXIMO-USER-ID" and PROXY to our upstream Maximo API server.
                set $HEADER_MAXIMO $JWT_MIP_EMPLOYEEID;
                # Proxy the request to the /jwt_claim NGINX location as JWT custom claim contains the Maximo UserID.
                set $MAXIMO_INTERNAL_URI maximo/api/jwt_claim/; # The trailing slash is required.
            }            
    # Check for HTTP Request Header value for Maximo UserID:
            if ($http_maximo_user_id ~* "^[a-zA-Z0-9@-_]+$") {
                # if an incoming Request Header MAXIMO-USER-ID is valid, then set the NGINX placeholder variable for proxy_set_header.        
                set $HEADER_MAXIMO $http_maximo_user_id;
                # Proxy the request to the /http_header NGINX location as Request Header MAXIMO-USER-ID contains the Maximo UserID.
                set $MAXIMO_INTERNAL_URI maximo/api/http_header/; # The trailing slash is required.                
            }

    # Check that the variable for Maximo UserID has been set by previous HTTP Request Header or JWT custom claim:        
            if ($HEADER_MAXIMO ~* "not_assigned_value") {
                return 597;
            }

            # Set the Request Header using the NGINX placeholder variable which was assigned in the previous IF conditional blocks.           
            proxy_set_header MAXIMO-USER-ID $HEADER_MAXIMO;
            proxy_set_header REQUEST-MAXIMO $request;  # store the original request URI in a header to be used in final proxy_pass directive.
            proxy_pass http://nginx_api_gateway/$MAXIMO_INTERNAL_URI; # Proxy the request to the NGINX internal location according to the variable assignment.            
            #access_log /var/log/nginx/access_jwt.log jwt;
            access_log /var/log/nginx/postdata.log postdata;
            access_log /var/log/nginx/access.log jwt;
            access_log /var/log/nginx/access_debug.log access_debug if=$is_error; # Diagnostic logging
        }
    # ----------------- Use this location when the Maximo UserID is sent in the JWT custom claim:
        location /maximo/api/jwt_claim/ {
            status_zone jwt_claim; # Enable statistics collection for this location.
            if ($http_maximo_user_id !~* "^[a-zA-Z0-9@-_]+$") {
                return 598;
            }
            expires -1;         # disable NGINX cache by short expiry
            proxy_no_cache 1;   # disable NGINX cache
            proxy_http_version 1.1; # By default NGINX uses HTTP/1.0 for connections to upstream servers and accordingly adds the Connection: close header to the requests that it forwards to the servers. 
            proxy_set_header   "Connection" ""; # removes the close value from the Connection header.
            #auth_jwt "api-domain.auth0.com";
            ###auth_jwt_key_file /etc/nginx/secret.json;       # Keycloak IDP Secret Certificates for JWT signature validation.
            #auth_jwt_key_file /etc/nginx/secret-microsoft.json;  # Azure IDP Secret Certificates for JWT signature validation.
            auth_request /_oauth2_token_cache_validation;
            auth_request_set $maximo_apikey $sent_http_maximoapikey;  # this MGINX global variable is set using the HTTP response header from previous auth_request which called an NJS function.
            error_page 500 =401 /502-authRequest.html;
            proxy_set_header apikey $maximo_apikey;       # Use this Maximo apikey for authorization in the API server.
            proxy_set_header Cookie "";   # An empty string means this header will not be passed to upstream server.
            proxy_set_header Authorization "";  # Maximo does not require the JWT. An empty string will prevent it being sent in the proxy_pass to upstream server.
            proxy_set_header MAXIMO-USER-ID ""; # Maximo does not use this header. An empty string will prevent it being sent in the proxy_pass to upstream server.
            proxy_set_header REQUEST-MAXIMO ""; # Maximo does not use this header, it is only used below as a carrier for original Maximo client request variable. A blank value will prevent it being sent in the proxy_pass.
        # if an incoming JWT signature is valid and not expired, then PROXY to our upstream Maximo API server.        
        # Remove the last part of the URI "jwt_claim" - this was added in the first proxy location.
            #if ($request_uri ~* "(.*)/jwt_claim/") {             
        # Remove the method name from the original request variable from MIP client and construct the target URI.                
            if ($http_request_maximo ~* "[a-zA-Z]* *(/.*) HTTP") {
                #proxy_pass http://maximo-project2.vip.iwater.ie/$1; # Proxy the request to the api endpoint.
                proxy_pass http://maximo_api_server$1; # Proxy the request to the Maximo api endpoint.
                #proxy_pass http://localhost:8089$1; # Proxy the request to the api endpoint simulator.                
            }            
            #access_log /var/log/nginx/access_jwt.log jwt;
            access_log /var/log/nginx/postdata.log postdata;
            #access_log /var/log/nginx/access.log main;
        }
# ----------------- Use this location when the Maximo UserID is sent in the HTTP Request Header MAXIMO-USER-ID:
        location /maximo/api/http_header/ {
            status_zone http_header; # Enable statistics collection for this location.
            if ($http_maximo_user_id !~* "^[a-zA-Z0-9@-_]+$") {
                return 599;
            }
            expires -1;         # disable NGINX cache by short expiry
            proxy_no_cache 1;   # disable NGINX cache
            proxy_http_version 1.1; # By default NGINX uses HTTP/1.0 for connections to upstream servers and accordingly adds the Connection: close header to the requests that it forwards to the servers. 
            proxy_set_header   "Connection" ""; # removes the close value from the Connection header.            
            #auth_jwt "api-domain.auth0.com";
            ###auth_jwt_key_file /etc/nginx/secret.json;       # Keycloak IDP Secret Certificates
            #auth_jwt_key_file /etc/nginx/secret-microsoft.json;  # Azure IDP Secret Certificates for JWT signature validation.
            auth_request /_oauth2_token_cache_validation;
            auth_request_set $maximo_apikey $sent_http_maximoapikey;  # this MGINX global variable is set using the HTTP response header from previous auth_request which called an NJS function.
            error_page 500 =401 /502-authRequest.html;
            proxy_set_header apikey $maximo_apikey;       # Use this Maximo apikey for authorization in the API server.
            #proxy_set_header apikey 99999;
            proxy_set_header Cookie "";   # An empty string means this header will not be passed to upstream server.
            proxy_set_header Authorization "";  # Maximo does not require the JWT. A blank value will prevent it being sent in the proxy_pass.
            proxy_set_header MAXIMO-USER-ID ""; # Maximo does not use this header. A blank value will prevent it being sent in the proxy_pass.
            proxy_set_header REQUEST-MAXIMO ""; # Maximo does not use this header, it is only used below as a carrier for original Maximo client request variable. A blank value will prevent it being sent in the proxy_pass.
        # if an incoming JWT signature is valid and not expired , then PROXY to our upstream Maximo API server.        
        # Remove the last part of the URI "http_header" - this was added in the first proxy location.
            #if ($request_uri ~* "(.*)/http_header/") {       
        # Remove the method name from the original request variable from MIP client and construct the target URI.                
            if ($http_request_maximo ~* "[a-zA-Z]* *(/.*) HTTP") {
                #proxy_pass http://maximo-project2.vip.iwater.ie/$1; # Proxy the request to the api endpoint.
                proxy_pass http://maximo_api_server$1; # Proxy the request to the Maximo api endpoint.
                #proxy_pass http://localhost:8089$1; # Proxy the request to the api endpoint simulator.                
            }
            #access_log /var/log/nginx/access_jwt.log jwt;
            access_log /var/log/nginx/postdata.log postdata;
            #access_log /var/log/nginx/access.log main;
        }                 
    # ======================= Maximo Integration Project SECTION END ========================================= 
    # ...               
        location /lua {
           # MIME type determined by default_type:
           default_type 'text/plain';
           content_by_lua '
               if jit then
                 ngx.say(jit.version)
               else
                 ngx.say("Not LuaJIT !")
               end
           ';
        }
    # ...
    # ...
        location /jsontest {
           # MIME type determined by default_type:
           default_type 'text/plain';
           content_by_lua_block {
               ngx.say('Hello,world!')               
               local json = require "json"
               local cjson = require "cjson"
-- local sampleJson = [[{"age":"23","testArray":{"array":[8,9,11,14,25]},"name":"Pat Barry"}]];
-- local sampleJson = { true, { foo = "bar" } };
-- local json = cjson.encode(sampleJson);
               local sampleJson = '{"name":"kieran","job":"architect"}';
               local json1 = json.encode(sampleJson);
               local json2 = cjson.encode(sampleJson);
               local json_stripped1 = string.gsub(json2, [[\"]], [[]]);
               local json_stripped2 = string.gsub(json_stripped1, [["]], [[]]);
               local lua_table = cjson.decode(sampleJson);
               ngx.say('lua_table[name] = ', lua_table["name"])

-- ngx.log(ngx.NOTICE, 'Lua Logger NOTICE: json1 = ', json1);
-- ngx.log(ngx.NOTICE, 'Lua Logger NOTICE: json1 = ', json1);
-- ngx.log(ngx.NOTICE, 'Lua Logger NOTICE: json2 = ', json2);
-- ngx.log(ngx.NOTICE, 'Lua Logger NOTICE: json_stripped1 = ', json_stripped1);
-- ngx.log(ngx.NOTICE, 'Lua Logger NOTICE: json_stripped2 = ', json_stripped2);
-- ngx.log(ngx.NOTICE, 'Lua Logger NOTICE: lua_table[name] = ', lua_table["name"]);

           }
        }
    # ...
        location /lua_content {
           # MIME type determined by default_type:
           default_type 'text/plain';
           content_by_lua_block {
               ngx.say('Hello,world!')
               ngx.say('Host: ', ngx.req.get_headers()["Host"])

               local log_file = require "logging.file";
               local logger = log_file("/tmp/Lua-Test-%s.log", "%Y-%m-%d");
               logger:info("Lua HTTP Resty test START");

               local http = require "socket.http"
               local ltn12 = require "ltn12"
               local respbody = {}
               local  body, code, headers, status = http.request {
                   method = "GET",
                   url = "https://api.coindesk.com/v1/bpi/currentprice.json",
                   headers =
                           {
                                   ["Accept"] = "*/*",
                                   ["Accept-Encoding"] = "gzip, deflate",
                                   ["Accept-Language"] = "en-us",
                                   ["Content-Type"] = "application/x-www-form-urlencoded",
                           },
                   sink = ltn12.sink.table(respbody)
               }
               ngx.say('HTTP response body  = ', body )
               ngx.say('HTTP response sink  = ', table.concat(respbody) )
           }
           # Set Response Header:
           header_filter_by_lua_block {
               ngx.header["Kieran-Response-Header"] = "Kieran Test"
           }
        }
    # ...
        location /lua_httpresty {
           # MIME type determined by default_type:
           default_type 'text/plain';
           content_by_lua_block {
               ngx.say('Hello,world!')
               ngx.say('Host: ', ngx.req.get_headers()["Host"])

               local log_file = require "logging.file";
               local logger = log_file("/tmp/Lua-Test-%s.log", "%Y-%m-%d");
               logger:info("Lua HTTP Resty test START");

               local httpc = require("resty.http").new();
               local status;
               local length;
               local body;
               local res, err = httpc:request_uri("http://www.thomas-bayer.com", {
                    method = "GET",
                    path = "/sqlrest",
                    headers = {
                       ["User-Agent"] = "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.111 Safari/537/36",
                       ["Content-Type"] = "application/x-www-form-urlencoded"
                    }
                });
               if res.status then
                   status = res.status;
                   length = res.headers["Content-Length"];
                   body   = res.body;
                   logger:info("Lua HTTP Resty request succeeded- " .. status);
                   logger:info("Lua HTTP Resty request succeeded- " .. body);
                   ngx.say('Lua HTTP Resty: ', body);
               else
                   ngx.log(ngx.ERR, "Lua HTTP Resty request failed: ", err);
                   logger:info("Lua HTTP Resty request failed - " .. status);
               end
           }
           # Set Response Header:
           header_filter_by_lua_block {
               ngx.header["Kieran-Response-Header"] = "Kieran Test";
           }
        }
    # ...
    # - Test script to call an external URL.
        location = /a {
           content_by_lua '
               local http = require "resty.http"
               local httpc = http.new()
               local ok, err1 = httpc:connect{
                   scheme = "http",
                   host = "www.thomas-bayer.com",
                   port = 80
               }

               local res, err2 = httpc:request{
                   path = "/sqlrest"
               }

               ngx.status = res.status
               ngx.say(res.reason)
               ngx.say(res.status)
               ngx.print(res:read_body())

               httpc:close()
           ';
        }
    # ...
    # - Test script to call an external URL.
        location = /b {
           content_by_lua '
               local http = require("resty.http")
               --Establish http Client instance
               local httpc = http.new()

               local resp, err = httpc:request_uri("http://www.thomas-bayer.com", {
                   method = "GET",
                   path = "/sqlrest",
                   headers = {
                       ["User-Agent"] = "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.111 Safari/537/36"
                   }
               })

               if not resp then
                   ngx.say("request error :", err)
                   return
               end

               --Get the status code
               ngx.status = resp.status

               --Get the response header
               for k, v in pairs(resp.headers) do
                   if k ~= "Transfer-Encoding" and k ~= "Connection" then
                       ngx.header[k] = v
                   end
               end
               --Response volume
               ngx.say(resp.body)

               httpc:close()
           ';
        }
    # ...
    # - Test script to call an external URL.
        location /lua_http_1 {
          default_type 'text/html';
          lua_code_cache on;
          content_by_lua_file /usr/local/openresty/nginx/scripts/test_http_1.lua;
        }
    # ...
    }

}


# TCP/UDP proxy and load balancing block
#
#stream {
    # Example configuration for TCP load balancing

    #upstream stream_backend {
    #    zone tcp_servers 64k;
    #    server backend1.example.com:12345;
    #    server backend2.example.com:12345;
    #}

    #server {
    #    listen 12345;
    #    status_zone tcp_server;
    #    proxy_pass stream_backend;
    #}
#}
